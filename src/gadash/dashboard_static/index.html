<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CR Inverse Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" onerror="window.chartJsLoadFailed=true;"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" onerror="window.katexLoadFailed=true;">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" onerror="window.katexLoadFailed=true;"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" onerror="window.katexLoadFailed=true;"></script>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --bg: #f1f5f9;
        --card: #ffffff;
        --header-bg: #0f172a;
        --text: #1e293b;
        --muted: #94a3b8;
        --border: #e2e8f0;
        --accent: #6366f1;
        --good: #22c55e;
        --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
        --shadow-md: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.06);
        --radius: 10px;
        --panel-aspect: 2 / 1;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        padding: 16px;
        min-height: 100vh;
      }
      .header {
        background: var(--header-bg);
        color: white;
        padding: 14px 20px;
        border-radius: var(--radius);
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      .header-title { font-size: 18px; font-weight: 800; letter-spacing: -0.3px; }
      .header-sub { font-size: 12px; color: var(--muted); margin-top: 2px; }
      .status {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
        background: #1e293b;
        padding: 6px 10px;
        border-radius: 999px;
      }
      .dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; }
      .dot.on { background: var(--good); box-shadow: 0 0 6px var(--good); }

      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        align-items: start;
      }
      .row2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      @media (max-width: 960px) {
        .row2 { grid-template-columns: 1fr; }
      }
      .card {
        background: var(--card);
        border-radius: var(--radius);
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
        padding: 14px 16px;
      }
      .controls {
        display: grid;
        grid-template-columns: 1fr 1.2fr 1fr 1fr 1fr 1fr 1fr 1fr auto;
        gap: 10px;
        align-items: end;
        margin-top: 10px;
      }
      @media (max-width: 1100px) {
        .controls { grid-template-columns: 1fr 1fr 1fr; }
      }
      .field label {
        display: block;
        font-size: 11px;
        color: #64748b;
        font-weight: 700;
        margin-bottom: 4px;
      }
      .field input, .field select {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
        background: #f8fafc;
        color: #0f172a;
        font-size: 12px;
        outline: none;
      }
      .field input:focus, .field select:focus {
        border-color: rgba(99,102,241,0.55);
        box-shadow: 0 0 0 3px rgba(99,102,241,0.15);
      }
      .toggleRow {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #f8fafc;
        height: 38px;
      }
      .toggleRow .kpi { margin: 0; }
      .btn {
        appearance: none;
        border: 0;
        border-radius: 12px;
        padding: 10px 14px;
        background: linear-gradient(180deg, #111827, #0b1220);
        color: #fff;
        font-weight: 800;
        font-size: 12px;
        cursor: pointer;
        height: 38px;
        box-shadow: var(--shadow);
      }
      .btn:active { transform: translateY(1px); }
      .btn.secondary {
        background: #f8fafc;
        color: #0f172a;
        border: 1px solid var(--border);
        box-shadow: none;
      }
      .btn.danger {
        background: linear-gradient(180deg, #ef4444, #b91c1c);
      }
      .runStatus {
        margin-top: 10px;
        font-size: 12px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        color: #0f172a;
        background: #f8fafc;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
        min-height: 44px;
        white-space: pre-wrap;
        word-break: break-word;
        line-height: 1.45;
      }
      .runStatusLabel {
        font-size: 11px;
        color: #64748b;
        font-weight: 700;
        margin-top: 10px;
        margin-bottom: 6px;
      }
      details.adv { margin-top: 10px; }
      details.adv summary {
        cursor: pointer;
        font-size: 12px;
        font-weight: 800;
        color: #0f172a;
        user-select: none;
      }
      .controls.loss {
        grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
        margin-top: 8px;
      }
      @media (max-width: 1100px) {
        .controls.loss { grid-template-columns: 1fr 1fr 1fr; }
      }
      .panel {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }
      .kpi { font-size: 12px; color: #64748b; }
      .kpi b { color: var(--text); }
      .bar {
        width: 100%; height: 6px; border-radius: 999px;
        background: #e5e7eb; overflow: hidden; margin-top: 8px;
      }
      .bar > div {
        height: 100%; width: 0%;
        background: linear-gradient(90deg, #60a5fa, #34d399);
        transition: width 0.2s ease;
      }
      .segmented {
        display: inline-flex;
        border: 1px solid var(--border);
        border-radius: 10px;
        overflow: hidden;
        background: #f8fafc;
      }
      .seg-btn {
        appearance: none;
        border: 0;
        background: transparent;
        color: #475569;
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 700;
        cursor: pointer;
        border-right: 1px solid var(--border);
      }
      .seg-btn:last-child { border-right: 0; }
      .seg-btn.active { background: #0f172a; color: white; }
      /* Keep optima + spectrum chart areas the same height. */
      .chartBox {
        position: relative;
        width: 100%;
        height: 360px;
        margin-top: 10px;
      }
      .chartBox canvas { width: 100% !important; height: 100% !important; }

      .thumbs { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; }
      @media (max-width: 960px) { .thumbs { grid-template-columns: repeat(3, 1fr); } }
      @media (max-width: 600px) { .thumbs { grid-template-columns: repeat(2, 1fr); } }
      .thumb {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px;
        background: #f8fafc;
        cursor: pointer;
      }
      .thumb.sel { outline: 2px solid var(--accent); }
      .thumb img { width: 100%; border-radius: 8px; image-rendering: pixelated; display: block; }
      .cap { font-size: 11px; color: #64748b; margin-top: 6px; }
      .hint { font-size: 11px; color: #64748b; margin-top: 6px; }
      .purityBox {
        margin-top: 10px;
        background: #f8fafc;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
        color: #0f172a;
        font-size: 12px;
        line-height: 1.6;
      }
      .purityMono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; font-size: 11px; color: #334155; }
      .purityPanel {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      @media (max-width: 960px) {
        .purityPanel { grid-template-columns: 1fr; }
      }
      .purityTable {
        background: #f8fafc;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;
        font-size: 12px;
        line-height: 1.65;
        color: #0f172a;
        white-space: pre;
        font-variant-numeric: tabular-nums;
        overflow: auto;
        min-height: 240px;
      }
      .purityViz {
        background: #f8fafc;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
      }
      .purityVizRow {
        display: grid;
        grid-template-columns: 1fr 22px;
        gap: 10px;
        align-items: center;
      }
      .purityCanvasWrap {
        width: min(320px, 100%);
        aspect-ratio: 1 / 1;
        justify-self: center;
        align-self: center;
      }
      .purityCanvasWrap canvas {
        width: 100% !important;
        height: 100% !important;
        display: block;
        border-radius: 8px;
        background: white;
      }
      .cbar {
        width: 22px;
        height: 100%;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, #ffffff, #000000);
      }
      .cbarLabel {
        font-size: 10px;
        color: #64748b;
        text-align: center;
        margin-top: 6px;
      }
      .cbarTicks {
        display: flex;
        justify-content: space-between;
        font-size: 10px;
        color: #64748b;
        margin-top: 6px;
      }
      .formulaBox {
        margin-top: 10px;
        background: #f8fafc;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
        color: #0f172a;
        overflow: auto;
        max-height: 420px;
      }
      .formulaLatex {
        font-size: 13px;
        line-height: 1.85;
        white-space: pre-wrap;
      }
      .katex { font-size: 1.0em; }
    </style>
  </head>
  <body>
    <div class="header">
      <div>
        <div class="header-title">CR Inverse Dashboard</div>
        <div class="header-sub">Optimization loss, progress, Top-K, and spectrum</div>
      </div>
      <div class="status"><span id="dot" class="dot"></span><span id="statusText">disconnected</span></div>
    </div>

    <div class="grid">
      <!-- Run controls -->
      <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Run</b> start optimization from dashboard</div>
          <div class="toggleRow">
            <div class="kpi"><b>FDTD verify</b></div>
            <input id="fdtdToggle" type="checkbox" />
          </div>
          <div class="toggleRow">
            <div class="kpi"><b>Dry-run</b></div>
            <input id="dryRunToggle" type="checkbox" />
          </div>
        </div>
        <div class="controls">
          <div class="field">
            <label for="inDevice">device</label>
            <select id="inDevice">
              <option value="cpu">cpu</option>
              <option value="cuda" selected>cuda</option>
            </select>
          </div>
          <div class="field">
            <label for="inOptimizer">optimizer</label>
            <select id="inOptimizer">
              <option value="ga" selected>GA</option>
              <option value="cmaes">CMA-ES</option>
              <option value="cmaes-multi">CMA-ES (Multi-Start)</option>
            </select>
          </div>
          <div class="field">
            <label for="inGenBackend">generator</label>
            <select id="inGenBackend">
              <option value="rule_mfs" selected>rule_mfs (soft)</option>
              <option value="rule_mfs_scipy">rule_mfs_scipy (exact)</option>
            </select>
          </div>
          <div class="field">
            <label for="inNumRuns">Number of parallel runs</label>
            <input id="inNumRuns" type="number" min="1" max="20" step="1" value="1" />
            <small style="color:#666; margin-top:4px; display:block;">1=single run, 2+=multi-start with seeds: 0, 1000, 2000, ...</small>
          </div>
          <div class="field">
            <label for="inNStart">n_start</label>
            <input id="inNStart" type="number" min="1" step="1" value="100" />
          </div>
          <div class="field">
            <label for="inNSteps">n_steps</label>
            <input id="inNSteps" type="number" min="1" step="1" value="1000" />
          </div>
          <div class="field">
            <label for="inTopk">topk</label>
            <input id="inTopk" type="number" min="1" step="1" value="10" />
          </div>
          <div class="field">
            <label for="inChunk">chunk_size</label>
            <input id="inChunk" type="number" min="1" step="1" value="32" />
          </div>
          <div class="field">
            <label for="inFdtdEvery">fdtd_every</label>
            <input id="inFdtdEvery" type="number" min="0" step="1" value="10" />
          </div>
          <button class="btn" id="runBtn">Run optimization</button>
          <button class="btn secondary" id="resumeBtn" type="button">Resume</button>
          <button class="btn secondary" id="stopBtn" type="button">Stop</button>
          <button class="btn danger" id="resetBtn" type="button">Reset</button>
        </div>
        <div class="runStatusLabel">Run Status</div>
        <div class="runStatus" id="runStatus">idle</div>

        <details class="adv">
          <summary>Common parameters</summary>
          <div class="controls loss">
            <div class="field">
              <label for="inWPurity">w_purity</label>
              <input id="inWPurity" type="number" step="0.01" value="1.0" />
            </div>
            <div class="field">
              <label for="inWAbs">w_abs</label>
              <input id="inWAbs" type="number" step="0.01" value="0.0" />
            </div>
            <div class="field">
              <label for="inWFill">w_fill</label>
              <input id="inWFill" type="number" step="0.1" value="1.0" />
            </div>
            <div class="field">
              <label for="inFillMin">fill_min</label>
              <input id="inFillMin" type="number" step="0.01" value="0.2" />
            </div>
            <div class="field">
              <label for="inFillMax">fill_max</label>
              <input id="inFillMax" type="number" step="0.01" value="0.5" />
            </div>
            <div class="field">
              <label for="inPurityDistW">purity_dist_w</label>
              <input id="inPurityDistW" type="number" step="0.1" value="0" title="Spectral-distance weight: 0=uniform, >0=far-band contamination penalized more" />
            </div>
            <div class="field">
              <label for="inWR">w_R (rgb)</label>
              <input id="inWR" type="number" min="0" step="0.1" value="1.0" />
            </div>
            <div class="field">
              <label for="inWG">w_G (rgb)</label>
              <input id="inWG" type="number" min="0" step="0.1" value="2.0" />
            </div>
            <div class="field">
              <label for="inWB">w_B (rgb)</label>
              <input id="inWB" type="number" min="0" step="0.1" value="1.0" />
            </div>
          </div>
        </details>

        <details class="adv" id="gaParamsSection" style="display:none;">
          <summary>GA parameters</summary>
          <div class="controls loss">
            <div class="field">
              <label for="inMutP">mutation_p</label>
              <input id="inMutP" type="number" step="0.05" value="0.2" />
            </div>
            <div class="field">
              <label for="inMutSig">mutation_sigma</label>
              <input id="inMutSig" type="number" step="0.01" value="0.15" />
            </div>
            <div class="field">
              <label for="inCloneK">topk_clone_k</label>
              <input id="inCloneK" type="number" min="0" step="1" value="8" />
            </div>
            <div class="field">
              <label for="inCloneM">topk_clone_m</label>
              <input id="inCloneM" type="number" min="0" step="1" value="0" />
            </div>
            <div class="field">
              <label for="inCloneSigMin">clone_sigma_min</label>
              <input id="inCloneSigMin" type="number" min="0" step="0.01" value="0.02" />
            </div>
            <div class="field">
              <label for="inCloneSigMax">clone_sigma_max</label>
              <input id="inCloneSigMax" type="number" min="0" step="0.01" value="0.08" />
            </div>
          </div>
        </details>

        <details class="adv" id="cmaesParamsSection" style="display:none;">
          <summary>CMA-ES parameters</summary>
          <div class="controls loss">
            <div class="field">
              <label for="inCmaSigma0">cma_sigma0</label>
              <input id="inCmaSigma0" type="number" min="0" step="0.01" value="0.3" />
            </div>
          </div>
        </details>
      </div>

      <!-- Top row: optima (left) + spectrum (right), same size -->
      <div class="row2">
        <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Optimization</b> <span id="kpiStep">-</span></div>
          <div class="row" style="gap:8px">
            <div class="kpi">Y</div>
            <div class="segmented" id="scaleToggle">
              <button class="seg-btn" data-scale="log">Log</button>
              <button class="seg-btn" data-scale="linear">Linear</button>
            </div>
            <div class="kpi">Window</div>
            <div class="segmented" id="windowToggle">
              <button class="seg-btn" data-window="all">All</button>
              <button class="seg-btn" data-window="200">200</button>
              <button class="seg-btn" data-window="50">50</button>
            </div>
          </div>
        </div>
        <div class="bar"><div id="progFill"></div></div>
        <div class="row" style="margin-top:8px">
          <div class="kpi">loss_total: <b id="kpiLoss">-</b></div>
        </div>
        <div class="chartBox"><canvas id="lossChart"></canvas></div>
        </div>

        <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Spectrum</b> <span id="kpiSpec">-</span></div>
          <div class="kpi" id="specHint">click a thumbnail</div>
        </div>
        <div class="chartBox"><canvas id="specChart"></canvas></div>
      </div>
      </div>

      <!-- Bottom row: Top-K (left) + Loss formula (right) -->
      <div class="row2">
        <div class="card panel">
          <div class="row">
            <div class="kpi"><b>Top-K</b> <span id="kpiTopk">-</span></div>
          <div class="row" style="gap:8px">
              <div class="kpi">Mode</div>
              <div class="segmented" id="topkModeToggle">
                <button class="seg-btn" data-topk_mode="best">Best</button>
                <button class="seg-btn" data-topk_mode="cur">Current</button>
              </div>
              <div class="toggleRow" style="height:32px;padding:6px 10px">
                <div class="kpi"><b>Invert</b></div>
                <input id="invertToggle" type="checkbox" />
              </div>
              <div class="kpi" id="topkHint"></div>
            </div>
          </div>
          <div class="thumbs" id="thumbs"></div>
          <div class="hint">Tip: click a thumbnail to update spectrum.</div>
        </div>

        <div class="card panel">
          <div class="row">
            <div class="kpi"><b>Loss Definition</b></div>
            <div class="kpi">loss function used for GA fitness</div>
          </div>
          <div class="formulaBox">
            <div class="formulaLatex" id="lossFormula"></div>
            <pre id="lossFormulaTex" style="display:none"></pre>
          </div>
        </div>
      </div>

      <!-- Bottom: Purity matrix (numeric + heatmap) -->
      <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Purity Matrix</b> <span id="kpiPurity">-</span></div>
          <div class="kpi" id="purityHint">computed from the currently selected spectrum</div>
        </div>
        <div class="purityPanel">
          <div class="purityTable" id="purityTable">waiting for first spectrum...</div>
          <div class="purityViz">
            <div class="purityVizRow">
              <div class="purityCanvasWrap"><canvas id="purityCanvas" width="320" height="320"></canvas></div>
              <div>
                <div class="cbar" title="color scale fixed to [0,1]"></div>
                <div class="cbarTicks"><span>1</span><span>0</span></div>
                <div class="cbarLabel">value</div>
              </div>
            </div>
          </div>
        </div>
      </div>

    <script>
      const dot = document.getElementById('dot');
      const statusText = document.getElementById('statusText');
      const kpiStep = document.getElementById('kpiStep');
      const kpiLoss = document.getElementById('kpiLoss');
      const progFill = document.getElementById('progFill');
      const kpiTopk = document.getElementById('kpiTopk');
      const thumbs = document.getElementById('thumbs');
      const topkHint = document.getElementById('topkHint');
      const kpiSpec = document.getElementById('kpiSpec');
      const specHint = document.getElementById('specHint');
      const kpiPurity = document.getElementById('kpiPurity');
      const purityHint = document.getElementById('purityHint');
      const purityTable = document.getElementById('purityTable');
      const purityCanvas = document.getElementById('purityCanvas');
      let lastPurityA = null;

      function resizePurityCanvas(){
        if (!purityCanvas) return;
        const wrap = purityCanvas.closest('.purityCanvasWrap');
        const cssSize = Math.max(1, Math.floor((wrap ? wrap.clientWidth : 320) || 320));
        const dpr = window.devicePixelRatio || 1;
        const px = Math.floor(cssSize * dpr);
        if (purityCanvas.width !== px || purityCanvas.height !== px) {
          purityCanvas.width = px;
          purityCanvas.height = px;
          if (lastPurityA) drawPurityHeatmap(lastPurityA);
        }
      }

      function setStatus(ok, text){
        dot.classList.toggle('on', ok);
        statusText.textContent = text;
      }
      async function fetchJSON(url){
        const r = await fetch(url, {cache:'no-store'});
        if (!r.ok) throw new Error(String(r.status));
        return await r.json();
      }
      function withCacheBust(u, token, invert){
        try{
          const url = new URL(u, window.location.href);
          url.searchParams.set('v', String(token));
          url.searchParams.set('invert', (invert ? '1' : '0'));
          return url.pathname + url.search;
        } catch(e) {
          // Fallback: naive.
          const inv = (invert ? '1' : '0');
          return u + (u.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(String(token)) + '&invert=' + inv;
        }
      }

      const ui = {
        scale: localStorage.getItem('loss_scale') || 'log',
        window: localStorage.getItem('loss_window') || 'all',
        fdtd: (localStorage.getItem('fdtd_verify') || 'off'),
        dryrun: (localStorage.getItem('dry_run') || 'off'),
        topk_mode: (localStorage.getItem('topk_mode') || 'best'),
        invert_view: (localStorage.getItem('invert_view') || 'on'),
        selected: {step:null, idx:0},
        lastTopkKey: ''
      };

      function initSegmented(el, key, values){
        const buttons = Array.from(el.querySelectorAll('.seg-btn'));
        function sync(){
          buttons.forEach(b => b.classList.toggle('active', b.dataset[key] === ui[key]));
        }
        buttons.forEach(b => {
          b.addEventListener('click', () => {
            ui[key] = b.dataset[key];
            if (key === 'scale' || key === 'window') localStorage.setItem('loss_' + key, ui[key]);
            if (key === 'topk_mode') localStorage.setItem('topk_mode', ui[key]);
            sync();
            redraw();
          });
        });
        // default
        if (!values.includes(ui[key])) ui[key] = values[0];
        sync();
      }

      let lossChart = null;
      let specChart = null;

      function setRunStatus(text){
        const el = document.getElementById('runStatus');
        if (el) el.textContent = text || '';
      }

      function makeLossChart(){
        const ctx = document.getElementById('lossChart');
        const gridColor = '#e2e8f0';
        const tickColor = '#94a3b8';
        const fontFamily = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';
        // Define colors for each loss component
        const lossColors = {
          'loss_total': { border: '#1f2937', bg: 'rgba(31,41,55,0.1)' },      // Dark (bold)
          'loss_spec': { border: '#3b82f6', bg: 'rgba(59,130,246,0.08)' },    // Blue
          'loss_reg': { border: '#8b5cf6', bg: 'rgba(139,92,246,0.08)' },     // Purple
          'loss_purity': { border: '#ef4444', bg: 'rgba(239,68,68,0.08)' },   // Red
          'loss_fill': { border: '#f59e0b', bg: 'rgba(245,158,11,0.08)' }     // Orange
        };

        const datasets = [];
        for (const [loss_key, colors] of Object.entries(lossColors)) {
          datasets.push({
            label: loss_key,
            data: [],
            borderColor: colors.border,
            backgroundColor: colors.bg,
            fill: (loss_key === 'loss_total'),  // Only fill total loss
            borderWidth: (loss_key === 'loss_total') ? 2.5 : 1.5,
            tension: 0.4,
            pointRadius: 0,
            pointHoverRadius: 4,
            hidden: (loss_key !== 'loss_total' && loss_key !== 'loss_spec')  // Hide others by default
          });
        }

        lossChart = new Chart(ctx, {
          type: 'line',
          data: { labels: [], datasets: datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
              y: {
                type: 'logarithmic',
                grid: { color: gridColor },
                ticks: { color: tickColor, font: { size: 11, family: fontFamily } },
                title: {
                  display: true,
                  text: (ui.scale === 'linear') ? 'Loss' : 'Loss (log)',
                  color: tickColor,
                  font: { size: 12, family: fontFamily }
                }
              },
              x: {
                grid: { color: gridColor, display: false },
                ticks: { color: tickColor, font: { size: 11, family: fontFamily }, maxTicksLimit: 20 },
                title: { display: true, text: 'step', color: tickColor, font: { size: 12, family: fontFamily } }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'line', font: { size: 12, family: fontFamily } }
              },
              tooltip: {
                backgroundColor: '#0f172a',
                titleFont: { size: 12, family: fontFamily },
                bodyFont: { size: 11, family: fontFamily },
                callbacks: {
                  label: (ctx) => {
                    const name = (ctx && ctx.dataset && ctx.dataset.label) ? String(ctx.dataset.label) : 'loss';
                    const v = (ctx && ctx.parsed) ? ctx.parsed.y : null;
                    if (v == null || !Number.isFinite(v)) return `${name}: --`;
                    const s = (v >= 0.01) ? v.toFixed(6) : v.toExponential(3);
                    return `${name}: ${s}`;
                  },
                }
              }
            }
          }
        });
      }

      function makeSpecChart(){
        const ctx = document.getElementById('specChart');
        const gridColor = '#e2e8f0';
        const tickColor = '#94a3b8';
        const fontFamily = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';
        specChart = new Chart(ctx, {
          type: 'line',
          data: { labels: [], datasets: [
            // Predicted (forward model): dashed + lighter.
            { label: 'R pred', data: [], borderColor: 'rgba(239,68,68,0.35)', borderWidth: 2, borderDash: [6,4], pointRadius: 0, tension: 0.4 },
            { label: 'G pred', data: [], borderColor: 'rgba(34,197,94,0.35)', borderWidth: 2, borderDash: [6,4], pointRadius: 0, tension: 0.4 },
            { label: 'B pred', data: [], borderColor: 'rgba(59,130,246,0.35)', borderWidth: 2, borderDash: [6,4], pointRadius: 0, tension: 0.4 },
            // FDTD verified: solid.
            { label: 'R fdtd', data: [], borderColor: '#ef4444', borderWidth: 2, pointRadius: 0, tension: 0.4, hidden: true },
            { label: 'G fdtd', data: [], borderColor: '#22c55e', borderWidth: 2, pointRadius: 0, tension: 0.4, hidden: true },
            { label: 'B fdtd', data: [], borderColor: '#3b82f6', borderWidth: 2, pointRadius: 0, tension: 0.4, hidden: true },
          ]},
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            parsing: false,
            interaction: { mode: 'nearest', intersect: false },
            scales: {
              x: {
                type: 'linear',
                min: 400,
                max: 700,
                grid: { display: false },
                ticks: { color: tickColor, font: { size: 10, family: fontFamily }, maxTicksLimit: 16 },
                title: { display: true, text: 'wavelength (nm)', color: tickColor, font: { size: 11, family: fontFamily } }
              },
              y: {
                grid: { color: gridColor },
                ticks: { color: tickColor, font: { size: 10, family: fontFamily } },
                title: { display: true, text: 'intensity', color: tickColor, font: { size: 11, family: fontFamily } }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'line', font: { size: 11, family: fontFamily }, boxWidth: 20 }
              },
              tooltip: {
                backgroundColor: '#0f172a',
                titleFont: { size: 12, family: fontFamily },
                bodyFont: { size: 11, family: fontFamily }
              }
            }
          }
        });
      }

      function updateLossScale(){
        if (!lossChart) return;
        lossChart.options.scales.y.type = (ui.scale === 'log') ? 'logarithmic' : 'linear';
        if (lossChart.options.scales.y.title) {
          lossChart.options.scales.y.title.text = (ui.scale === 'linear') ? 'Loss' : 'Loss (log)';
        }
      }

      let lastStatus = null;

      async function redraw(){
        // use cached status to update chart options quickly
        if (lastStatus) {
          applyStatus(lastStatus);
        }
      }

      function applyStatus(st){
        const meta = st.meta || {};
        const series = st.series || {};
        const steps = series.steps || [];
        const total = Number(meta.n_steps);

        const latest = st.latest || {};
        const curStep = Number(latest.step);
        if (Number.isFinite(curStep)) {
          kpiStep.textContent = (Number.isFinite(total) && total>0) ? `(step ${curStep} / ${total-1})` : `(step ${curStep})`;
          if (Number.isFinite(total) && total>0) {
            const pct = Math.max(0, Math.min(1, curStep / Math.max(1, total-1))) * 100;
            progFill.style.width = pct.toFixed(1) + '%';
          }
        }
        const lt = Number(latest.loss_total);
        kpiLoss.textContent = Number.isFinite(lt) ? lt.toFixed(6) : '-';

        // windowing
        let windowN = ui.window === 'all' ? null : Number(ui.window);
        let startIdx = 0;
        if (windowN && steps.length > windowN) startIdx = steps.length - windowN;

        const x = steps.slice(startIdx);

        // Check if this is multi-seed data
        const isMultiSeed = st.merged === true;
        const seedLossTotal = series['seed_loss_total'];
        const seedLossSpec = series['seed_loss_spec'];
        const seedLossReg = series['seed_loss_reg'];
        const seedLossPurity = series['seed_loss_purity'];
        const seedLossFill = series['seed_loss_fill'];

        updateLossScale();
        lossChart.data.labels = x.map(String);

        if (isMultiSeed && seedLossTotal) {
          // Multi-seed mode: create separate dataset for each seed
          const seedKeys = Object.keys(seedLossTotal).sort();
          const seedColors = ['#0ea5e9', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#6366f1', '#14b8a6', '#eab308', '#d946ef', '#0891b2', '#7c3aed', '#f97316'];

          // Clear existing datasets and create new ones for each seed
          lossChart.data.datasets = [];

          // Add average loss first (so it appears behind individual seeds)
          const avgValues = (seedLossTotal['avg'] || []).slice(startIdx);
          if (avgValues.length > 0) {
            lossChart.data.datasets.push({
              label: 'avg (전체평균)',
              data: avgValues,
              borderColor: '#000000',
              backgroundColor: 'transparent',
              fill: false,
              borderWidth: 3,
              borderDash: [5, 5],
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 5
            });
          }

          // Add individual seed datasets
          for (let si = 0; si < seedKeys.length; si++) {
            const seed = seedKeys[si];
            if (seed === 'avg') continue; // Skip the average key
            const color = seedColors[si % seedColors.length];
            const seedStr = `seed_${seed}`;
            const seedValues = (seedLossTotal[seed] || []).slice(startIdx);
            lossChart.data.datasets.push({
              label: seedStr,
              data: seedValues,
              borderColor: color,
              backgroundColor: 'transparent',
              fill: false,
              borderWidth: 2,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 5
            });
          }
        } else {
          // Single-seed mode: use loss components
          const lossKeys = ['loss_total', 'loss_spec', 'loss_reg', 'loss_purity', 'loss_fill'];
          const lossData = {};
          for (const key of lossKeys) {
            lossData[key] = (series[key] || []).slice(startIdx);
          }

          // Update all loss datasets
          for (let i = 0; i < lossChart.data.datasets.length; i++) {
            const label = lossChart.data.datasets[i].label;
            lossChart.data.datasets[i].data = lossData[label] || [];
          }
        }

        lossChart.update();

        renderLatexFromMeta(meta);

        // Quick visibility: show generator backend used by the last meta.
        try{
          const gb = (meta.generator && meta.generator.backend) ? String(meta.generator.backend) : '';
          const rs = document.getElementById('runStatus');
          if (rs && gb) {
            const cur = rs.textContent || '';
            if (!cur.includes('generator=')) {
              rs.textContent = (cur ? (cur + '   ') : '') + `generator=${gb}`;
            }
          }
        } catch(e) {}
      }

      function numOr(x, d){
        const v = Number(x);
        return Number.isFinite(v) ? v : d;
      }

      function renderLatexFromMeta(meta){
        // Prefer meta.loss from run_meta.json (written by inverse_opt.py).
        const L = (meta && meta.loss) ? meta.loss : {};
        const S = (meta && meta.spectra) ? meta.spectra : {};
        const W = (S && S.rgb_weights) ? S.rgb_weights : {};
        const w_purity = numOr(L.w_purity, 1.0);
        const w_abs = numOr(L.w_abs, 0.0);
        const w_fill = numOr(L.w_fill, 1.0);
        const fill_min = numOr(L.fill_min, 0.2);
        const fill_max = numOr(L.fill_max, 0.5);
        const pDistW = numOr(L.purity_dist_w, 0.0);
        const wR = numOr(W.R, 1.0);
        const wG = numOr(W.G, 1.0);
        const wB = numOr(W.B, 1.0);

        // Keep the original KaTeX auto-render approach: inject $$...$$ and call renderMathInElement.
        const pDistLine = (pDistW !== 0.0)
          ? `W_{ij}=1+${pDistW.toFixed(2)}\\,|i-j|,\\quad L_{\\mathrm{purity}}=\\sum_{i,j}W_{ij}(A_{ij}-I_{ij})^2`
          : `L_{\\mathrm{purity}}=\\lVert A-I\\rVert_F^2`;
        const texBody = `\\begin{aligned}
&\\textbf{Weights (configured):}\\\\
&w_{\\mathrm{purity}} = ${w_purity.toFixed(4)}\\qquad w_{\\mathrm{abs}} = ${w_abs.toFixed(4)}\\qquad w_{\\mathrm{fill}} = ${w_fill.toFixed(4)}\\\\
&w_R = ${wR.toFixed(2)}\\qquad w_G = ${wG.toFixed(2)}\\qquad w_B = ${wB.toFixed(2)}\\\\[10pt]
&\\textbf{Purity matrix }(3{\\times}3)\\textbf{:}\\\\
&\\qquad A_{ij} = w_i \\cdot \\mathrm{mean}(S_i,\\ \\mathrm{band}_j)\\\\
&\\textbf{Spectral loss components:}\\\\
&${pDistLine}\\\\
&L_{\\mathrm{abs}}=\\lVert \\mathbf{1}-\\mathrm{diag}(A)\\rVert_2^2\\\\
&L_{\\mathrm{spec}}=w_{\\mathrm{purity}} \\cdot L_{\\mathrm{purity}}+w_{\\mathrm{abs}} \\cdot L_{\\mathrm{abs}}\\\\[8pt]
&\\textbf{Fill constraint:}\\\\
&f=\\mathrm{mean}(\\text{struct}),\\quad f\\in[${fill_min.toFixed(3)},\\ ${fill_max.toFixed(3)}]\\\\
&L_{\\mathrm{fill}}=\\mathrm{softplus}(${fill_min.toFixed(3)}-f)^2+\\mathrm{softplus}(f-${fill_max.toFixed(3)})^2\\\\[8pt]
&\\textbf{Total loss:}\\\\
&L_{\\mathrm{total}}=L_{\\mathrm{spec}}+w_{\\mathrm{fill}} \\cdot L_{\\mathrm{fill}}
\\end{aligned}`;

        const box = document.getElementById('lossFormula');
        if (!box) return;
        box.textContent = `$$\n${texBody}\n$$`;
        if (window.renderMathInElement) {
          try{
            renderMathInElement(box, {
              delimiters: [{left:'$$', right:'$$', display:true}, {left:'$', right:'$', display:false}]
            });
          } catch(e) {}
        }
      }

      async function tick(){
        try{
          await fetchJSON('/api/ping');
          setStatus(true, 'live');
        } catch(e) {
          setStatus(false, 'disconnected');
          return;
        }

        try{
          const st = await fetchJSON('/api/status?window=all');
          lastStatus = st;
          applyStatus(st);
        } catch(e) { /* ignore */ }

        // Run status (multi-seed aware)
        try{
          const rs = await fetchJSON('/api/run/status');
          const seedsStatus = rs.seeds_status || {};
          const activeSeeds = rs.active_seeds || [];
          const numRunning = rs.num_running || 0;

          if (activeSeeds.length > 1 || numRunning > 1) {
            // Multi-seed display
            const parts = [];
            for (const s of activeSeeds) {
              const ss = seedsStatus[String(s)];
              if (!ss) continue;
              const label = ss.running ? 'running' : (ss.last_exit_code != null ? `exit=${ss.last_exit_code}` : 'idle');
              parts.push(`seed=${s}: ${label}`);
            }
            const tail = rs.tail || [];
            const lastLine = tail.length ? '\n' + tail[tail.length - 1] : '';
            setRunStatus(`${numRunning}/${activeSeeds.length} running  |  ${parts.join('  |  ')}${lastLine}`);
          } else if (rs.running) {
            const tail = rs.tail || [];
            setRunStatus('running: ' + (tail.length ? tail[tail.length-1] : '...'));
          } else if (activeSeeds.length > 0) {
            const s0 = activeSeeds[0];
            const ss = seedsStatus[String(s0)];
            if (ss && ss.last_exit_code != null) {
              setRunStatus('last exit: ' + ss.last_exit_code);
            }
          } else if (rs.last_exit_code != null) {
            setRunStatus('last exit: ' + rs.last_exit_code);
          }
        } catch(e) { /* ignore */ }

        // TopK (multi-seed aware)
        try{
          const t = await fetchJSON(`/api/topk/latest?mode=${encodeURIComponent(ui.topk_mode)}`);
          if (t.step == null) {
            kpiTopk.textContent = '(no snapshot)';
            thumbs.innerHTML = '';
            topkHint.textContent = '';
            return;
          }
          const isMerged = !!t.merged;
          const seedOrigins = t.seed_origins || [];
          const seedSteps = t.seed_steps || {};
          const nSeeds = Object.keys(seedSteps).length;
          const key = String(t.mode||ui.topk_mode) + ':' + String(t.step) + ':' + String(t.k) + ':' + (isMerged ? 'merged' : 'single');

          if (isMerged) {
            kpiTopk.textContent = `(merged ${nSeeds} seeds, K=${t.k}, mode=${t.mode||ui.topk_mode})`;
          } else {
            kpiTopk.textContent = `(step ${t.step}, K=${t.k}, mode=${t.mode||ui.topk_mode})`;
          }

          if (key !== ui.lastTopkKey) {
            ui.lastTopkKey = key;
            // Store merged data for spectrum lookup if merged
            ui._lastMergedTopk = isMerged ? t : null;
            const imgs = t.images || [];
            const fill = t.fill_frac || [];
            const best = (t.metrics && t.metrics.metric_best_loss) ? t.metrics.metric_best_loss : null;
            const cur = (t.metrics && t.metrics.metric_cur_loss) ? t.metrics.metric_cur_loss : null;
            let html = '';
            const maxShow = Math.min(imgs.length, 8);
            for (let i=0;i<maxShow;i++){
              const inv = (ui.invert_view === 'on');
              const src = withCacheBust(imgs[i], t.step, inv);
              const seedLabel = (isMerged && seedOrigins[i] != null) ? `seed=${seedOrigins[i]}  ` : '';
              const cap = [
                seedLabel ? seedLabel : null,
                (ui.topk_mode === 'cur') && cur && cur[i]!=null ? `cur_loss=${Number(cur[i]).toFixed(6)}` : null,
                (ui.topk_mode !== 'cur') && best && best[i]!=null ? `best_loss=${Number(best[i]).toFixed(6)}` : null,
                fill && fill[i]!=null ? `fill=${Number(fill[i]).toFixed(3)}` : null
              ].filter(Boolean).join('  ') || `k=${i}`;
              html += `<div class="thumb" data-step="${t.step}" data-idx="${i}" data-merged="${isMerged?1:0}"><img src="${src}" onerror="this.closest('.thumb').classList.add('err'); this.alt='image failed';" /><div class="cap">${cap}</div></div>`;
            }
            thumbs.innerHTML = html;
            if (isMerged) {
              topkHint.textContent = `best from ${nSeeds} seeds — click a thumb to plot spectrum`;
            } else {
              topkHint.textContent = 'click a thumb to plot spectrum';
            }

            // auto-select k=0
            ui.selected.step = t.step;
            ui.selected.idx = 0;
            await loadSpectrum(t.step, 0);
          }
        } catch(e) { /* ignore */ }

      }

      function _getRgbWeightsFromMeta(){
        const meta = lastStatus ? (lastStatus.meta || {}) : {};
        const S = meta.spectra || {};
        const W = S.rgb_weights || {};
        return {
          R: numOr(W.R, 1.0),
          G: numOr(W.G, 1.0),
          B: numOr(W.B, 1.0),
        };
      }

      function computePurityFromRgb(rgb){
        // rgb: [3][C] arrays, order [R,G,B]
        if (!rgb || !rgb.length || !rgb[0] || !rgb[0].length) return null;
        const C = rgb[0].length;
        const w = _getRgbWeightsFromMeta();

        // Apply per-detector weights (same as Python spectral.py purity_matrix)
        const S = [
          rgb[0].map(v => w.R * Number(v)),  // R detector
          rgb[1].map(v => w.G * Number(v)),  // G detector
          rgb[2].map(v => w.B * Number(v)),  // B detector
        ];

        // Wavelength bands: B=short, G=mid, R=long (same as spectral.py bands_for_rgb)
        const e1 = Math.floor(C / 3);
        const e2 = Math.floor((2 * C) / 3);
        const bandR = {i0: e2, i1: C};
        const bandG = {i0: e1, i1: e2};
        const bandB = {i0: 0, i1: e1};

        const mean = (arr, i0, i1) => {
          const n = Math.max(1, i1 - i0);
          let sum = 0;
          for (let i=i0;i<i1;i++) sum += Number(arr[i]);
          return sum / n;
        };

        // A: rows = detector [R,G,B], cols = band [R,G,B]
        // Matches Python spectral.py: idx = {"R":0, "G":1, "B":2}
        const A = [
          [mean(S[0], bandR.i0, bandR.i1), mean(S[0], bandG.i0, bandG.i1), mean(S[0], bandB.i0, bandB.i1)],
          [mean(S[1], bandR.i0, bandR.i1), mean(S[1], bandG.i0, bandG.i1), mean(S[1], bandB.i0, bandB.i1)],
          [mean(S[2], bandR.i0, bandR.i1), mean(S[2], bandG.i0, bandG.i1), mean(S[2], bandB.i0, bandB.i1)],
        ];

        // Diagonal: A[0][0]=R/R, A[1][1]=G/G, A[2][2]=B/B
        const diag = [A[0][0], A[1][1], A[2][2]];
        let off = 0, cnt = 0;
        for (let r=0;r<3;r++){
          for (let c=0;c<3;c++){
            if (r !== c){
              off += A[r][c];
              cnt += 1;
            }
          }
        }
        const offdiag_mean = (cnt>0) ? (off/cnt) : 0;
        return {A, diag, offdiag_mean, C, w};
      }

      function drawPurityHeatmap(A){
        if (!purityCanvas) return;
        lastPurityA = A;
        resizePurityCanvas();
        const ctx = purityCanvas.getContext('2d');
        const W = purityCanvas.width, H = purityCanvas.height;
        ctx.clearRect(0,0,W,H);
        ctx.imageSmoothingEnabled = false;

        const padL = 34, padT = 26, padR = 6, padB = 10;
        const gridW = W - padL - padR;
        const gridH = H - padT - padB;
        const cellW = gridW / 3.0;
        const cellH = gridH / 3.0;

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,W,H);

        for (let r=0;r<3;r++){
          for (let c=0;c<3;c++){
            const v = Math.max(0, Math.min(1, Number(A[r][c] || 0)));
            const g = Math.round(255 * (1.0 - v)); // black=1
            ctx.fillStyle = `rgb(${g},${g},${g})`;
            ctx.fillRect(padL + c*cellW, padT + r*cellH, cellW, cellH);
          }
        }

        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 2;
        for (let i=0;i<=3;i++){
          ctx.beginPath();
          ctx.moveTo(padL + i*cellW, padT);
          ctx.lineTo(padL + i*cellW, padT + 3*cellH);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(padL, padT + i*cellH);
          ctx.lineTo(padL + 3*cellW, padT + i*cellH);
          ctx.stroke();
        }

        ctx.fillStyle = '#64748b';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';
        const col = ['R','G','B'];
        for (let c=0;c<3;c++){
          const x = padL + c*cellW + cellW/2;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(col[c], x, 12);
        }
        const row = ['R','G','B'];
        for (let r=0;r<3;r++){
          const y = padT + r*cellH + cellH/2;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(row[r], 16, y);
        }
      }

      function renderPurity(p, step, idx){
        if (!p || !p.A) {
          if (purityTable) purityTable.textContent = 'waiting for first spectrum...';
          if (kpiPurity) kpiPurity.textContent = '-';
          if (purityHint) purityHint.textContent = 'computed from the currently selected spectrum';
          if (purityCanvas) {
            const ctx = purityCanvas.getContext('2d');
            ctx.clearRect(0,0,purityCanvas.width,purityCanvas.height);
          }
          return;
        }
        if (kpiPurity) kpiPurity.textContent = `(step ${step}, k=${idx})`;
        const A = p.A;
        const w = p.w || {R:1,G:1,B:1};
        const fmt = (x) => (Number.isFinite(Number(x)) ? Number(x).toFixed(4) : '----');
        // rows=detector [R,G,B], cols=band [R,G,B] (matches Python spectral.py)
        const lines = [
          `weights: w_R=${w.R.toFixed(1)}  w_G=${w.G.toFixed(1)}  w_B=${w.B.toFixed(1)}`,
          '',
          '         R_band   G_band   B_band',
          `R_det  ${fmt(A[0][0])}   ${fmt(A[0][1])}   ${fmt(A[0][2])}`,
          `G_det  ${fmt(A[1][0])}   ${fmt(A[1][1])}   ${fmt(A[1][2])}`,
          `B_det  ${fmt(A[2][0])}   ${fmt(A[2][1])}   ${fmt(A[2][2])}`,
          '',
          `diag: R=${fmt(A[0][0])} G=${fmt(A[1][1])} B=${fmt(A[2][2])}`,
        ];
        if (purityTable) purityTable.textContent = lines.join('\n');
        if (purityHint) purityHint.textContent = 'ideal = identity (diagonal=1, off-diag=0)';
        drawPurityHeatmap(A);
      }

      async function loadSpectrum(step, idx){
        kpiSpec.textContent = `(step ${step}, k=${idx})`;
        let rgb = null;
        let frgb = null;
        let fdtdStepUsed = null;
        let C = 0;

        // Track if any data actually loaded (to avoid flickering)
        let dataLoaded = false;

        // Determine which seed to use for spectrum (for merged topk)
        let specSeedParam = '';
        const isMerged = ui._lastMergedTopk && ui._lastMergedTopk.merged;
        if (isMerged && ui._lastMergedTopk.seed_origins && ui._lastMergedTopk.seed_origins[idx] != null) {
          const seed = ui._lastMergedTopk.seed_origins[idx];
          specSeedParam = `&seed=${seed}`;
        }

        // 1) Try surrogate spectrum (optional)
        try{
          const specUrl = `/api/topk/${step}/${idx}/spectrum?mode=${encodeURIComponent(ui.topk_mode)}${specSeedParam}`;
          console.log('Loading spectrum:', specUrl);
          const s = await fetchJSON(specUrl);
          console.log('Spectrum response:', s);
          rgb = s.rgb || null;
          if (rgb && rgb[0] && rgb[0].length) {
            dataLoaded = true;
            C = rgb[0].length;
            // Only clear and update if data is actually available
            specChart.data.datasets[0].data = toXY(rgb[0]);
            specChart.data.datasets[1].data = toXY(rgb[1]);
            specChart.data.datasets[2].data = toXY(rgb[2]);
            specChart.data.datasets[0].hidden = false;
            specChart.data.datasets[1].hidden = false;
            specChart.data.datasets[2].hidden = false;
          }
        } catch(e) {
          console.error('Spectrum load error:', e);
          rgb = null;
        }

        // 2) Try FDTD overlay independently (optional)
        if (ui.fdtd === 'on') {
          try{
            const f = await fetchJSON(`/api/topk/${step}/${idx}/fdtd_spectrum?fallback=1${specSeedParam}`);
            if (f && f.rgb && f.rgb[0] && f.rgb[0].length) {
              dataLoaded = true;
              frgb = f.rgb;
              fdtdStepUsed = (f.fdtd_step != null) ? Number(f.fdtd_step) : Number(step);
              C = Math.max(C, frgb[0].length);
              // Display-only transform requested: negate FDTD overlay.
              specChart.data.datasets[3].data = toXY(frgb[0].map(v => -Number(v)));
              specChart.data.datasets[4].data = toXY(frgb[1].map(v => -Number(v)));
              specChart.data.datasets[5].data = toXY(frgb[2].map(v => -Number(v)));
              specChart.data.datasets[3].hidden = false;
              specChart.data.datasets[4].hidden = false;
              specChart.data.datasets[5].hidden = false;
            }
          } catch(e) {
            frgb = null;
          }
        }

        // 3) Labels/update/hints - only update chart if data was actually loaded
        specChart.data.labels = [];
        if (dataLoaded) {
          specChart.update();
        }

        if (rgb && frgb) {
          if (fdtdStepUsed === Number(step)) specHint.textContent = `pred vs FDTD: 3x${C} (400-700 nm)`;
          else specHint.textContent = `pred vs FDTD(step ${fdtdStepUsed}): 3x${C} (400-700 nm)`;
          const p = computePurityFromRgb(rgb);
          renderPurity(p, step, idx);
          return;
        }
        if (rgb && !frgb) {
          specHint.textContent = `forward only: 3x${C} (400-700 nm)`;
          const p = computePurityFromRgb(rgb);
          renderPurity(p, step, idx);
          return;
        }
        if (!rgb && frgb) {
          specHint.textContent = (fdtdStepUsed === Number(step))
            ? `FDTD only: 3x${C} (400-700 nm)`
            : `FDTD only(step ${fdtdStepUsed}): 3x${C} (400-700 nm)`;
          renderPurity(null, step, idx);
          return;
        }
        specHint.textContent = 'spectrum unavailable (no surrogate / no FDTD snapshot)';
        renderPurity(null, step, idx);
      }

      thumbs.addEventListener('click', async (ev) => {
        const el = ev.target.closest('.thumb');
        if (!el) return;
        const stepStr = el.getAttribute('data-step');
        const idxStr = el.getAttribute('data-idx');
        if (stepStr == null || idxStr == null) return;
        const step = Number(stepStr);
        const idx = Number(idxStr);
        ui.selected.step = step;
        ui.selected.idx = idx;
        Array.from(thumbs.querySelectorAll('.thumb')).forEach(x => x.classList.toggle('sel', x === el));
        await loadSpectrum(step, idx);
      });

      initSegmented(document.getElementById('scaleToggle'), 'scale', ['log','linear']);
      initSegmented(document.getElementById('windowToggle'), 'window', ['all','200','50']);
      initSegmented(document.getElementById('topkModeToggle'), 'topk_mode', ['best','cur']);
      makeLossChart();
      makeSpecChart();

      // Invert view toggle (display-only).
      const invertToggle = document.getElementById('invertToggle');
      if (invertToggle) {
        invertToggle.checked = (ui.invert_view === 'on');
        invertToggle.addEventListener('change', () => {
          ui.invert_view = invertToggle.checked ? 'on' : 'off';
          localStorage.setItem('invert_view', ui.invert_view);
          ui.lastTopkKey = ''; // force thumbs refresh
        });
      }

      // FDTD verify toggle + run button
      const fdtdToggle = document.getElementById('fdtdToggle');
      if (fdtdToggle) {
        fdtdToggle.checked = (ui.fdtd === 'on');
        fdtdToggle.addEventListener('change', () => {
          ui.fdtd = fdtdToggle.checked ? 'on' : 'off';
          localStorage.setItem('fdtd_verify', ui.fdtd);
          // refresh spectrum overlay if a thumb is selected
          if (ui.selected.step != null) loadSpectrum(ui.selected.step, ui.selected.idx);
        });
      }

      function toXY(arr){
        if (!arr || !arr.length) return [];
        const n = arr.length;
        const out = new Array(n);
        for (let i=0;i<n;i++){
          const x = 400 + (300 * i) / Math.max(1, (n - 1));
          out[i] = { x, y: Number(arr[i]) };
        }
        return out;
      }

      // Toggle parameter sections based on optimizer selection
      function updateOptimizerSections() {
        const inOptimizer = document.getElementById('inOptimizer');
        const gaParamsSection = document.getElementById('gaParamsSection');
        const cmaesParamsSection = document.getElementById('cmaesParamsSection');

        if (!inOptimizer) return;

        const optValue = inOptimizer.value;

        // Show/hide parameter sections based on optimizer
        if (gaParamsSection) {
          gaParamsSection.style.display = (optValue === 'ga' || optValue === 'cmaes-multi') ? 'block' : 'none';
        }
        if (cmaesParamsSection) {
          cmaesParamsSection.style.display = (optValue === 'cmaes' || optValue === 'cmaes-multi') ? 'block' : 'none';
        }
      }

      const inOptimizer = document.getElementById('inOptimizer');
      if (inOptimizer) {
        inOptimizer.addEventListener('change', updateOptimizerSections);
        updateOptimizerSections(); // Initial state
      }

      const dryRunToggle = document.getElementById('dryRunToggle');
      if (dryRunToggle) {
        dryRunToggle.checked = (ui.dryrun === 'on');
        dryRunToggle.addEventListener('change', () => {
          ui.dryrun = dryRunToggle.checked ? 'on' : 'off';
          localStorage.setItem('dry_run', ui.dryrun);
        });
      }
      const runBtn = document.getElementById('runBtn');
      if (runBtn) {
        runBtn.addEventListener('click', async () => {
          const nStart = Number(document.getElementById('inNStart')?.value || 200);
          const nSteps = Number(document.getElementById('inNSteps')?.value || 2000);
          const topk = Number(document.getElementById('inTopk')?.value || 50);
          const dev = String(document.getElementById('inDevice')?.value || 'cpu');
          const optType_raw = String(document.getElementById('inOptimizer')?.value || 'ga');
          // Support both explicit 'cmaes-multi' and general multi-start for any optimizer
          const optType = (optType_raw === 'cmaes-multi') ? 'cmaes' : optType_raw;
          const numRuns = Number(document.getElementById('inNumRuns')?.value || 1);
          const isMultiStart = numRuns > 1 || optType_raw === 'cmaes-multi';
          const genBackend = String(document.getElementById('inGenBackend')?.value || 'rule_mfs');
          const chunk = Number(document.getElementById('inChunk')?.value || 32);
          const fdtdEvery = Number(document.getElementById('inFdtdEvery')?.value || 10);
          const cmaSigma0 = Number(document.getElementById('inCmaSigma0')?.value || 0.3);
          const wPurity = Number(document.getElementById('inWPurity')?.value || 1.0);
          const wAbs = Number(document.getElementById('inWAbs')?.value || 0.0);
          const wFill = Number(document.getElementById('inWFill')?.value || 1.0);
          const fillMin = Number(document.getElementById('inFillMin')?.value || 0.2);
          const fillMax = Number(document.getElementById('inFillMax')?.value || 0.5);
          const purityDistW = Number(document.getElementById('inPurityDistW')?.value || 0);
          const mutP = Number(document.getElementById('inMutP')?.value || 0.2);
          const mutSig = Number(document.getElementById('inMutSig')?.value || 0.15);
          const cloneK = Number(document.getElementById('inCloneK')?.value || 0);
          const cloneM = Number(document.getElementById('inCloneM')?.value || 0);
          const cloneSigMin = Number(document.getElementById('inCloneSigMin')?.value || 0.02);
          const cloneSigMax = Number(document.getElementById('inCloneSigMax')?.value || 0.08);
          const rgbWR = Number(document.getElementById('inWR')?.value || 1.0);
          const rgbWG = Number(document.getElementById('inWG')?.value || 2.0);
          const rgbWB = Number(document.getElementById('inWB')?.value || 1.0);

          // persist
          localStorage.setItem('loss_w_purity', String(wPurity));
          localStorage.setItem('loss_w_abs', String(wAbs));
          localStorage.setItem('loss_w_fill', String(wFill));
          localStorage.setItem('loss_fill_min', String(fillMin));
          localStorage.setItem('loss_fill_max', String(fillMax));
          localStorage.setItem('loss_purity_dist_w', String(purityDistW));
          localStorage.setItem('ga_mut_p', String(mutP));
          localStorage.setItem('ga_mut_sig', String(mutSig));
          localStorage.setItem('ga_clone_k', String(cloneK));
          localStorage.setItem('ga_clone_m', String(cloneM));
          localStorage.setItem('ga_clone_sig_min', String(cloneSigMin));
          localStorage.setItem('ga_clone_sig_max', String(cloneSigMax));
          localStorage.setItem('optimizer_type', optType);
          localStorage.setItem('cma_sigma0', String(cmaSigma0));
          localStorage.setItem('rgb_w_r', String(rgbWR));
          localStorage.setItem('rgb_w_g', String(rgbWG));
          localStorage.setItem('rgb_w_b', String(rgbWB));
          try{
            const dryRun = (ui.dryrun === 'on') ? 1 : 0;
            const baseUrl = `/api/run/start?n_start=${encodeURIComponent(nStart)}&n_steps=${encodeURIComponent(nSteps)}&topk=${encodeURIComponent(topk)}&dry_run=${encodeURIComponent(dryRun)}&device=${encodeURIComponent(dev)}&chunk_size=${encodeURIComponent(chunk)}&fdtd_verify=${ui.fdtd==='on'?1:0}&fdtd_every=${encodeURIComponent(fdtdEvery)}&ga_mutation_p=${encodeURIComponent(mutP)}&ga_mutation_sigma=${encodeURIComponent(mutSig)}&w_purity=${encodeURIComponent(wPurity)}&w_abs=${encodeURIComponent(wAbs)}&w_fill=${encodeURIComponent(wFill)}&fill_min=${encodeURIComponent(fillMin)}&fill_max=${encodeURIComponent(fillMax)}&purity_dist_w=${encodeURIComponent(purityDistW)}`;
            const urlSuffix = `&generator_backend=${encodeURIComponent(genBackend)}&ga_topk_clone_k=${encodeURIComponent(cloneK)}&ga_topk_clone_m=${encodeURIComponent(cloneM)}&ga_topk_clone_sigma_min=${encodeURIComponent(cloneSigMin)}&ga_topk_clone_sigma_max=${encodeURIComponent(cloneSigMax)}&optimizer_type=${encodeURIComponent(optType)}&cma_sigma0=${encodeURIComponent(cmaSigma0)}&rgb_weight_r=${encodeURIComponent(rgbWR)}&rgb_weight_g=${encodeURIComponent(rgbWG)}&rgb_weight_b=${encodeURIComponent(rgbWB)}`;

            // Multi-start: launch numRuns independent runs with different seeds
            const launched = [];
            const actualNumRuns = isMultiStart ? Math.max(2, numRuns) : 1;

            for (let runIdx = 0; runIdx < actualNumRuns; runIdx++) {
              const seedParam = isMultiStart ? `&seed=${runIdx * 1000}` : '';
              const url2 = baseUrl + urlSuffix + seedParam;
              const r = await fetch(url2, {method:'POST'});
              if (r.ok) {
                launched.push(runIdx);
              }
            }

            if (launched.length > 0) {
              // Clear caches for new run
              ui.lastTopkKey = '';
              ui._lastMergedTopk = null;
              thumbs.innerHTML = '';
              topkHint.textContent = '';
              console.log('New run started - caches cleared');
              if (actualNumRuns === 1) {
                setRunStatus('started');
              } else {
                const seeds = launched.map(i => i * 1000).join(', ');
                setRunStatus(`started ${launched.length} parallel runs (seeds: ${seeds})`);
              }
            } else {
              setRunStatus('failed to start any runs');
            }
          } catch(e) {
            setRunStatus('failed to start (network error)');
          }
        });
      }
      const stopBtn = document.getElementById('stopBtn');
      if (stopBtn) {
        stopBtn.addEventListener('click', async () => {
          try{
            // Stop all seeds (no seed param = stop all)
            const r = await fetch('/api/run/stop', {method:'POST'});
            if (!r.ok) throw new Error(String(r.status));
            const j = await r.json();
            if (j.stopped_seeds && j.stopped_seeds.length > 0) {
              setRunStatus(`stopped seeds: ${j.stopped_seeds.join(', ')}`);
            } else {
              setRunStatus(j.stopped ? 'stopped' : (j.error || 'no run'));
            }
          } catch(e) {
            setRunStatus('stop failed');
          }
        });
      }
      const resetBtn = document.getElementById('resetBtn');
      if (resetBtn) {
        resetBtn.addEventListener('click', async () => {
          if (!confirm('Reset progress? This archives current data/progress into data/progress_archive.')) return;
          try{
            const r = await fetch('/api/run/reset', {method:'POST'});
            if (!r.ok) throw new Error(String(r.status));
            const j = await r.json();
            ui.lastTopkKey = '';
            thumbs.innerHTML = '';
            topkHint.textContent = '';
            setRunStatus('reset ok');
          } catch(e) {
            setRunStatus('reset failed');
          }
        });
      }
      const resumeBtn = document.getElementById('resumeBtn');
      if (resumeBtn) {
        resumeBtn.addEventListener('click', async () => {
          const nStart = Number(document.getElementById('inNStart')?.value || 200);
          const nSteps = Number(document.getElementById('inNSteps')?.value || 2000);
          const topk = Number(document.getElementById('inTopk')?.value || 50);
          const dev = String(document.getElementById('inDevice')?.value || 'cpu');
          const optType = String(document.getElementById('inOptimizer')?.value || 'ga');
          const genBackend = String(document.getElementById('inGenBackend')?.value || 'rule_mfs');
          const chunk = Number(document.getElementById('inChunk')?.value || 32);
          const fdtdEvery = Number(document.getElementById('inFdtdEvery')?.value || 10);
          const cmaSigma0 = Number(document.getElementById('inCmaSigma0')?.value || 0.3);
          const wPurity = Number(document.getElementById('inWPurity')?.value || 1.0);
          const wAbs = Number(document.getElementById('inWAbs')?.value || 0.0);
          const wFill = Number(document.getElementById('inWFill')?.value || 1.0);
          const fillMin = Number(document.getElementById('inFillMin')?.value || 0.2);
          const fillMax = Number(document.getElementById('inFillMax')?.value || 0.5);
          const purityDistW = Number(document.getElementById('inPurityDistW')?.value || 0);
          const mutP = Number(document.getElementById('inMutP')?.value || 0.2);
          const mutSig = Number(document.getElementById('inMutSig')?.value || 0.15);
          const cloneK = Number(document.getElementById('inCloneK')?.value || 0);
          const cloneM = Number(document.getElementById('inCloneM')?.value || 0);
          const cloneSigMin = Number(document.getElementById('inCloneSigMin')?.value || 0.02);
          const cloneSigMax = Number(document.getElementById('inCloneSigMax')?.value || 0.08);
          const rgbWR = Number(document.getElementById('inWR')?.value || 1.0);
          const rgbWG = Number(document.getElementById('inWG')?.value || 2.0);
          const rgbWB = Number(document.getElementById('inWB')?.value || 1.0);
          try{
            const dryRun = (ui.dryrun === 'on') ? 1 : 0;
            const url = `/api/run/start?n_start=${encodeURIComponent(nStart)}&n_steps=${encodeURIComponent(nSteps)}&topk=${encodeURIComponent(topk)}&dry_run=${encodeURIComponent(dryRun)}&device=${encodeURIComponent(dev)}&chunk_size=${encodeURIComponent(chunk)}&fdtd_verify=${ui.fdtd==='on'?1:0}&fdtd_every=${encodeURIComponent(fdtdEvery)}&ga_mutation_p=${encodeURIComponent(mutP)}&ga_mutation_sigma=${encodeURIComponent(mutSig)}&w_purity=${encodeURIComponent(wPurity)}&w_abs=${encodeURIComponent(wAbs)}&w_fill=${encodeURIComponent(wFill)}&fill_min=${encodeURIComponent(fillMin)}&fill_max=${encodeURIComponent(fillMax)}&purity_dist_w=${encodeURIComponent(purityDistW)}`;
            const url2 = url + `&generator_backend=${encodeURIComponent(genBackend)}&ga_topk_clone_k=${encodeURIComponent(cloneK)}&ga_topk_clone_m=${encodeURIComponent(cloneM)}&ga_topk_clone_sigma_min=${encodeURIComponent(cloneSigMin)}&ga_topk_clone_sigma_max=${encodeURIComponent(cloneSigMax)}&optimizer_type=${encodeURIComponent(optType)}&cma_sigma0=${encodeURIComponent(cmaSigma0)}&rgb_weight_r=${encodeURIComponent(rgbWR)}&rgb_weight_g=${encodeURIComponent(rgbWG)}&rgb_weight_b=${encodeURIComponent(rgbWB)}&resume=1`;
            const r = await fetch(url2, {method:'POST'});
            const bodyText = await r.text();
            if (!r.ok) {
              setRunStatus(`failed to resume (${r.status}): ${bodyText || 'no details'}`);
              return;
            }
            setRunStatus('resumed');
          } catch(e) {
            setRunStatus('failed to resume (network error)');
          }
        });
      }

      function renderLatex(){
        // Initial render uses defaults; once /api/status arrives, applyStatus() re-renders from meta.
        renderLatexFromMeta(lastStatus ? (lastStatus.meta||{}) : {});
      }
      // KaTeX scripts are loaded with `defer`, so render on load (reference style).
      window.addEventListener('load', () => {
        renderLatex();
        resizePurityCanvas();
        window.addEventListener('resize', () => resizePurityCanvas());
        // If KaTeX is a little late (slow CDN), retry briefly.
        let tries = 0;
        const timer = setInterval(() => {
          tries += 1;
          if (window.renderMathInElement) renderLatex();
          if (tries >= 10) clearInterval(timer);
        }, 250);
      });

      tick();
      setInterval(tick, 1200);

      // Restore persisted weight inputs (dashboard-side defaults).
      function restoreLossInputs(){
        const set = (id, key, fallback) => {
          const el = document.getElementById(id);
          if (!el) return;
          const v = localStorage.getItem(key);
          if (v != null && v !== '') el.value = v;
          else el.value = String(fallback);
        };
        // optimizer type
        const ot = localStorage.getItem('optimizer_type');
        const otEl = document.getElementById('inOptimizer');
        if (otEl) {
          otEl.value = (ot === 'cmaes' || ot === 'cmaes-multi') ? ot : 'ga';
          otEl.addEventListener('change', () => localStorage.setItem('optimizer_type', otEl.value));
        }
        // generator backend
        const gb = localStorage.getItem('gen_backend');
        const gbEl = document.getElementById('inGenBackend');
        if (gbEl) {
          gbEl.value = (gb === 'rule_mfs_scipy') ? 'rule_mfs_scipy' : 'rule_mfs';
          gbEl.addEventListener('change', () => localStorage.setItem('gen_backend', gbEl.value));
        }
        set('inWPurity', 'loss_w_purity', 1.0);
        set('inWAbs', 'loss_w_abs', 0.0);
        set('inWFill', 'loss_w_fill', 1.0);
        set('inFillMin', 'loss_fill_min', 0.2);
        set('inFillMax', 'loss_fill_max', 0.5);
        set('inPurityDistW', 'loss_purity_dist_w', 0);
        set('inMutP', 'ga_mut_p', 0.2);
        set('inMutSig', 'ga_mut_sig', 0.15);
        set('inCloneK', 'ga_clone_k', 8);
        set('inCloneM', 'ga_clone_m', 0);
        set('inCloneSigMin', 'ga_clone_sig_min', 0.02);
        set('inCloneSigMax', 'ga_clone_sig_max', 0.08);
        set('inCmaSigma0', 'cma_sigma0', 0.3);
        set('inWR', 'rgb_w_r', 1.0);
        set('inWG', 'rgb_w_g', 2.0);
        set('inWB', 'rgb_w_b', 1.0);
      }
      restoreLossInputs();
      // Ensure parameter section visibility is correct after restore
      updateOptimizerSections();
    </script>
  </body>
</html>
